<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lobby - CS2 Matchmaking</title>
    <link rel="stylesheet" href="../styles/lobby.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <script src="/socket.io/socket.io.js"></script>
</head>
<body>
    <div class="lobby">
        <div class="lobby-header">
            <div class="match-title">
                <span id="matchup">Lobby</span>
            </div>
            <div class="turn-indicator" id="turnIndicator">Loading...</div>
        </div>

        <div class="lobby-stage">
            <aside class="team team-a">
                <div class="team-header">
                    <div class="team-name" id="teamAName">Team A</div>
                    <div class="team-captain" id="teamACaptain">Captain</div>
                </div>
                <ul class="team-players" id="teamAPlayers"></ul>
            </aside>

            <main class="veto-center">
                <div class="veto-flow">
                    <div class="veto-step active" id="vetoStep">üéØ Veto Phase</div>
                </div>
                <div class="veto-timer" id="vetoTimerCenter">00:30</div>
                <div class="map-grid" id="mapPool"></div>
                <div class="final-map hidden" id="finalMap">
                    <span class="label">üèÜ Final Map</span>
                    <span class="value" id="selectedMap"></span>
                </div>
            </main>

            <aside class="team team-b">
                <div class="team-header">
                    <div class="team-name" id="teamBName">Team B</div>
                    <div class="team-captain" id="teamBCaptain">Captain</div>
                </div>
                <ul class="team-players" id="teamBPlayers"></ul>
            </aside>
        </div>
    </div>

    <script>
        const params = new URLSearchParams(window.location.search);
        const socket = io('', {
            query: {
                userId: params.get('userId') || 'testUser',
                displayName: params.get('displayName') || 'TestUser'
            }
        });
        const lobbyId = params.get('lobbyId');
        let currentUserId = params.get('userId');
        let lastLobby = null;
        let lastTurnIndex = null;
        let turnDeadline = null;
        let timerInterval = null;

        if (!currentUserId) {
            fetch('/api/user')
                .then(r => r.json())
                .then(u => { 
                    currentUserId = String(u.id);
                    if (lastLobby) renderLobby(lastLobby);
                })
                .catch(() => {});
        }

        function renderLobby(lobby) {
            // Teams
            const aCaptain = lobby.captains[0];
            const bCaptain = lobby.captains[1];
            document.getElementById('teamAName').textContent = `Team ${aCaptain?.displayName || 'A'}`;
            document.getElementById('teamBName').textContent = `Team ${bCaptain?.displayName || 'B'}`;
            document.getElementById('teamACaptain').textContent = aCaptain ? aCaptain.displayName : '';
            document.getElementById('teamBCaptain').textContent = bCaptain ? bCaptain.displayName : '';

            document.getElementById('teamAPlayers').innerHTML = lobby.teams.A.map(p =>
                `<li class="player">${p.displayName}${lobby.captains.some(c => c.id === p.id) ? ' <span class="role">(C)</span>' : ''}</li>`
            ).join('');
            document.getElementById('teamBPlayers').innerHTML = lobby.teams.B.map(p =>
                `<li class="player">${p.displayName}${lobby.captains.some(c => c.id === p.id) ? ' <span class="role">(C)</span>' : ''}</li>`
            ).join('');

            // Header
            const matchup = `${aCaptain?.displayName || 'Team A'} vs ${bCaptain?.displayName || 'Team B'}`;
            document.getElementById('matchup').textContent = matchup;

            // Veto / Turn state
            const currentCaptain = lobby.captains[lobby.currentTurnIndex % 2];
            const myTurn = currentCaptain && String(currentCaptain.id) === String(currentUserId);
            
            // Timer lifecycle per turn
            if (!lobby.lobbyCompleted && lastTurnIndex !== lobby.currentTurnIndex) {
                lastTurnIndex = lobby.currentTurnIndex;
                turnDeadline = Date.now() + 30000; // 30 seconds
                if (timerInterval) clearInterval(timerInterval);
                timerInterval = setInterval(updateTimerUI, 250);
                updateTimerUI();
            }
            if (lobby.lobbyCompleted && timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            
            // Header indicator text will be set in updateTimerUI, fallback here if needed
            if (lobby.lobbyCompleted) {
                document.getElementById('turnIndicator').textContent = '‚úÖ Veto complete';
                document.getElementById('vetoTimerCenter').textContent = '';
            }

            // Map grid
            const mapPoolEl = document.getElementById('mapPool');
            mapPoolEl.innerHTML = '';
            const maps = Array.isArray(lobby.mapPool) ? lobby.mapPool : [];
            maps.forEach(map => {
                const btn = document.createElement('button');
                btn.className = 'map-card' + (myTurn ? ' actionable' : '');
                btn.textContent = `üó∫Ô∏è ${map}`;
                btn.disabled = !myTurn || lobby.lobbyCompleted;
                btn.onclick = () => socket.emit('lobbyAction', { lobbyId, action: 'ban', map });
                mapPoolEl.appendChild(btn);
            });

            // Final map
            const finalEl = document.getElementById('finalMap');
            if (lobby.lobbyCompleted) {
                finalEl.classList.remove('hidden');
                document.getElementById('selectedMap').textContent = lobby.finalMap;
            } else {
                finalEl.classList.add('hidden');
            }
        }

        function updateTimerUI() {
            if (!turnDeadline) return;
            const now = Date.now();
            const msRemaining = Math.max(0, turnDeadline - now);
            const seconds = Math.ceil(msRemaining / 1000);
            const padded = String(seconds).padStart(2, '0');
            const currentCaptain = lastLobby?.captains[lastLobby?.currentTurnIndex % 2];
            const myTurn = currentCaptain && String(currentCaptain.id) === String(currentUserId);
            const headerText = lastLobby?.lobbyCompleted
                ? '‚úÖ Veto complete'
                : `üéØ ${currentCaptain?.displayName || ''} is banning` + (myTurn ? ' (Your turn)' : '') + ` ‚Ä¢ 00:${padded}`;
            document.getElementById('turnIndicator').textContent = headerText;
            const centerEl = document.getElementById('vetoTimerCenter');
            if (centerEl) centerEl.textContent = lastLobby?.lobbyCompleted ? '' : `00:${padded}`;
            if (msRemaining <= 0 && timerInterval) {
                // Auto-ban if it's our turn and lobby still active
                autoBanIfNeeded();
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function autoBanIfNeeded() {
            if (!lastLobby || lastLobby.lobbyCompleted) return;
            const currentCaptain = lastLobby.captains[lastLobby.currentTurnIndex % 2];
            const myTurn = currentCaptain && String(currentCaptain.id) === String(currentUserId);
            if (!myTurn) return;
            const available = Array.isArray(lastLobby.mapPool) && lastLobby.mapPool.length
                ? lastLobby.mapPool.slice()
                : [];
            if (!available.length) return;
            const mapToBan = available[0];
            socket.emit('lobbyAction', { lobbyId, action: 'ban', map: mapToBan });
            turnDeadline = null;
        }

        socket.emit('joinLobby', lobbyId);

        socket.on('lobbyUpdated', (lobby) => {
            lastLobby = lobby;
            renderLobby(lobby);
        });

        socket.on('lobbyError', (msg) => {
            alert(msg);
        });
    </script>
</body>
</html>